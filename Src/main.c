/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "main.h"

int main(void)
{
    printf("Hello Embedded World!\n");

    init_scheduler_stack(SCHED_STACK_START);

    init_systick_timer(TICK_HZ);

	for(;;);
}

/*
 * This microcontroller family has a system timer, called SysTick. This timer is
 * configured thru 4 dedicated registers. Which are:
 * 			> SYST_CSR 		- SysTick Control and Status Register 	- 0xE000E010
 * 			> SYST_RVR 		- SysTick Reload Value Register 		- 0xE000E014
 * 			> SYST_CVR		- SysTick Current Value Register 		- 0xE000E018
 * 			> SYST_CALIB	- SysTick Calibration Value Register	- 0xE000E01C
 * The SysTick counts down from the reload value to zero, reloads with the value
 * in SYST_RVR, then counts down again, repeating the whole process.
 */
void init_systick_timer(uint32_t tick_hz)
{
	uint32_t *pSCSR = (uint32_t *) 0xE000E010;
	uint32_t *pSRVR = (uint32_t *) 0xE000E014;

	uint32_t count_value = (HSI_CLOCK / tick_hz) - 1;

	/* Reseting the value of SYST_RVR
	*		The bits from 24 to 31 are reserved in this register. So, we must clear
	*		only the bits from 0 to 23.
	*/
	*pSRVR &= ~(0x00FFFFFFFF);

	// Loading count_value to SYST_RVR
	*pSRVR |= count_value;

	/* The first three bit of SYST_CSR are used to configure the SysTick.
	 * 		> Bit 0: Enables the counter when it's value is 1;
	 * 		> Bit 1: Sets an exception to indicate when the counting reaches 0,
	 * 		         when it's value is 1;
	 * 		> Bit 2: Sets the clock source. If this bit is 0, the clock source
	 * 		         will be a external clock. If this bit is 1, the clock source
	 * 		         will be the processor's clock.
	 */

	// Setting the SysTick clock source to use the processor clock
	*pSCSR |= (1 << 2);

	// Enabling the SysTick exception request
	*pSCSR |= (1 << 1);

	// Enabling the counter
	*pSCSR |= (1 << 0);
}


__attribute__((naked))
void init_scheduler_stack(uint32_t stack_start_address)
{
	/* Changing the value of Main Stack Pointer (MSP)
	 *  - By default, SP points to MSP;
	 *	- Every time that the processor enters in thread mode, SP will
	 *	point to MSP;
	 *	- So, if MSP is holding the initial address of scheduler's stack,
	 *	SP will point by default to this address and if, for some reason,
	 *	SP starts to point to PSP, every time the processor enters in
	 *	thread mode, the SP will points to scheduler stack.
	 */
	__asm volatile("MSR MSP, R0"); // Moves the value from 1st argument on MSP
	__asm volatile("BX LR"); // Returns to caller
}

void init_task_stack (void)
{

}

void taskHandler1(void)
{
	for(;;)
	{
		printf("This is task 1!\n");
	}
}
void taskHandler2(void)
{
	for(;;)
	{
		printf("This is task 2!\n");
	}
}
void taskHandler3(void)
{
	for(;;)
	{
		printf("This is task 3!\n");
	}
}
void taskHandler4(void)
{
	for(;;)
	{
		printf("This is task 4!\n");
	}
}

void SysTick_Handler(void)
{
	printf("On %s()\n", __FUNCTION__);
}
